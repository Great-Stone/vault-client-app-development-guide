# Vault 시크릿을 사용하는 애플리케이션 개발 개요

## 개발 목표

**핵심 원칙: 코드에 비밀번호나 API 키를 절대 넣지 않기**

* ❌ **기존 방식**: 코드에 `password = "mypassword123"` 같은 하드코딩
* ✅ **새로운 방식**: Vault에서 동적으로 시크릿 가져오기

### 왜 이렇게 해야 하나요?

1. **보안 강화**: 코드가 유출되어도 시크릿이 노출되지 않음
2. **중앙 관리**: 모든 시크릿을 한 곳에서 관리
3. **자동 갱신**: 비밀번호가 바뀌어도 코드 수정 없이 자동 반영
4. **접근 제어**: 누가 어떤 시크릿에 접근할 수 있는지 세밀하게 제어

## Vault란 무엇인가요?

**HashiCorp Vault**는 시크릿(비밀번호, API 키, 인증서 등)을 안전하게 저장하고 관리하는 도구입니다.

* **시크릿 저장소**: 데이터베이스 비밀번호, API 키 등을 암호화해서 저장
* **동적 시크릿**: 필요할 때만 임시 비밀번호 생성 (자동 만료)
* **접근 제어**: 어떤 앱이 어떤 시크릿에 접근할 수 있는지 세밀하게 제어
* **감사 로그**: 누가 언제 어떤 시크릿에 접근했는지 기록

---

## 1안: Vault API 직접 연계 (권고안 ✅)

### 이 방식이란?

**애플리케이션이 직접 Vault 서버와 통신해서 시크릿을 가져오는 방식**입니다.

### 인증 과정 (쉽게 설명)

1. **AppRole 인증**: 앱이 Vault에 로그인하는 방법
   - `role_id`: 앱의 신분증 (공개)
   - `secret_id`: 앱의 비밀번호 (비공개)
   
2. **Token 발급**: 로그인 성공하면 Vault가 임시 토큰을 줌
   - 이 토큰으로 시크릿에 접근 가능
   - 토큰은 시간이 지나면 만료됨 (보안을 위해)
   
3. **Token 갱신**: 만료되기 전에 토큰을 새로 받아야 함
   - 자동으로 갱신하는 코드를 작성해야 함

### 개발자가 해야 할 일

#### 1단계: Vault 관리자가 먼저 설정 (개발자는 관심 없어도 됨)

```bash
# Vault 관리자가 실행하는 명령어들
vault auth enable approle
vault write auth/approle/role/myapp \
    secret_id_ttl=24h \
    token_ttl=1h \
    token_max_ttl=24h \
    period=1h \
    policies="myapp-policy"
```

**개발자에게 전달되는 것**: `role_id`와 `secret_id` (환경변수나 설정파일로)

#### 2단계: 앱에서 Vault에 로그인

```http
POST /v1/auth/approle/login
{
  "role_id": "앱의_신분증",
  "secret_id": "앱의_비밀번호"
}
```

**응답**: `client_token` (이걸로 시크릿에 접근 가능)

#### 3단계: 토큰 갱신 (중요!)

```http
POST /v1/auth/token/renew-self
X-Vault-Token: <받은_토큰>
```

**왜 필요한가?** 토큰은 1시간 후 만료되므로, 앱이 계속 실행되려면 주기적으로 갱신해야 함

#### 4단계: 시크릿 가져오기

```http
GET /v1/kv-demo/data/sample
X-Vault-Token: <갱신된_토큰>
```

**⚠️ 중요**: KV v2 시크릿 엔진 사용 시 경로에 `/data/`가 포함되어야 합니다.
- CLI: `vault kv get kv-demo/sample` 
- API: `/v1/kv-demo/data/sample`

**응답 예시**:
```json
{
  "data": {
    "data": {
      "username": "dbuser",
      "password": "secretpassword123"
    }
  }
}
```

#### 5단계: 앱에서 시크릿 사용

```javascript
// ❌ 이렇게 하면 안됨
const password = "hardcoded_password";

// ✅ 이렇게 해야 함
const password = vaultResponse.data.data.password;
// 메모리에서만 사용, 파일에 저장하지 않음
```

---

### 개발 시 필요한 설정 정보

개발자는 다음 정보들을 설정에 넣어야 합니다:

* **Vault 서버 주소**: `https://vault.company.com:8200`
* **Namespace**: 앱이 접근할 수 있는 Vault 영역 (보통 팀별로 구분)
* **Secret 경로**: 어떤 시크릿에 접근할 수 있는지 (`/kv/data/database` 등)
* **자동 갱신**: 토큰 만료 전에 자동으로 갱신하는 코드 필수

### 언어별 라이브러리 (개발자 도구)

* **C언어** → libcurl + json-c (예제 참고)
  - **완성된 예제**: [C언어 Vault 클라이언트](./c-app/) (개발자 배포용)
  - **지원 기능**: KV v2, Database Dynamic, Database Static 시크릿 엔진
  - **고급 기능**: 실시간 갱신, 버전 기반 캐싱, TTL 기반 갱신
  - **보안**: Entity 기반 권한, 자동 토큰 갱신, 메모리 보안
  - **설정**: INI 파일 기반 설정, 다중 시크릿 엔진 지원

* **Java** → Apache HttpClient + Jackson (예제 참고)
  - **완성된 예제**: [Java Vault 클라이언트](./pure-java-app/) (개발자 배포용)
  - **지원 기능**: KV v2, Database Dynamic, Database Static 시크릿 엔진
  - **고급 기능**: 실시간 TTL 계산, 버전 기반 캐싱, 멀티스레드 갱신
  - **보안**: Entity 기반 권한, 자동 토큰 갱신, 메모리 보안
  - **설정**: Properties 파일 기반 설정, 시스템 프로퍼티 오버라이드 지원
  - **호환성**: Java 11 이상에서 테스트, Maven 기반 빌드

**모든 언어에서 동일한 패턴**: 로그인 → 토큰 갱신 → 시크릿 가져오기

---

## 2안: Vault Proxy 사용

### Vault Proxy란?

**Vault Proxy**는 앱과 Vault 사이에 있는 중간 서버입니다.

* **앱의 역할**: Proxy에게 "시크릿 줘"라고 요청
* **Proxy의 역할**: Vault에서 시크릿을 가져와서 앱에게 전달
* **장점**: 앱에서 복잡한 인증/토큰 관리 코드를 작성할 필요 없음

### 개발자 관점에서의 차이점

**기존 1안 (직접 연계)**:
```javascript
// 복잡한 코드 필요
const token = await vaultLogin(roleId, secretId);
const secret = await vaultGetSecret(token, path);
await vaultRenewToken(token); // 주기적으로 실행
```

**Vault Proxy 사용**:
```javascript
// 매우 간단한 코드
const secret = await fetch('http://vault-proxy:8200/v1/kv/data/db');
```

### 장단점

**장점**:
- 앱 코드가 매우 간단해짐
- 토큰 관리 로직 불필요
- 개발 속도 향상

**단점**:
- Proxy 서버 추가 운영 필요
- Proxy가 모든 토큰을 가지고 있어서 보안 설계 중요

---

## 3안: Vault Agent + 환경변수/파일 주입 (레거시 앱용)

### 언제 사용하나요?

**API 연계가 어려운 경우**에 사용합니다:

* **레거시 앱**: 오래된 앱이라 HTTP API 연계가 어려움
* **외부 도구**: 써드파티 도구 (DB 클라이언트, 모니터링 도구 등)

### 동작 방식

1. **Vault Agent**가 백그라운드에서 실행
2. Agent가 Vault에서 시크릿을 주기적으로 가져옴
3. 시크릿을 **환경변수**로 직접 주입 (파일 저장 없음)
4. Agent가 C 프로그램을 실행하며 환경변수와 함께 전달
5. 앱은 `getenv()` 함수로 환경변수에서 시크릿 읽기

### 개발자 관점에서의 차이점

**기존 방식 (하드코딩)**:
```c
// ❌ 이렇게 하면 안됨
char* password = "hardcoded_password";
```

**Vault Agent 사용**:
```c
// ✅ 환경변수에서 읽기
char* password = getenv("DB_PASSWORD");
```

**환경변수에서 읽기 (권장)**:
```c
// ✅ 환경변수에서 직접 읽기 (Agent가 자동으로 주입)
char* password = getenv("FROM_VAULT_SECRET");
char* source = getenv("VAULT_SECRET_SOURCE");
char* timestamp = getenv("SECRET_TIMESTAMP");
```

**또는 설정파일에서 읽기**:
```c
// ✅ 파일에서 읽기 (Agent가 자동으로 업데이트)
// config.ini 파일 내용:
// [database]
// password = vault에서_가져온_비밀번호
```

### 설정 예시

**Vault Agent 설정** (`vault-agent.hcl`):
```hcl
# AppRole 인증 설정
auto_auth {
  method {
    type = "approle"
    namespace = "skt_demo"
    mount_path = "auth/approle"
    config = {
      role_id_file_path = "./role_id"
      secret_id_file_path = "./secret_id"
      remove_secret_id_file_after_reading = false
    }
  }
  
  sink "file" {
    config = {
      path = "./token"
    }
  }
}

# 환경변수 템플릿 설정 (파일로 저장하지 않고 직접 환경변수로 주입)
env_template "FROM_VAULT_SECRET" {
  contents = "{{ with secret \"kv-demo/data/sample\" }}{{ .Data.data.sample_secret }}{{ end }}"
  error_on_missing_key = true
}

env_template "VAULT_SECRET_SOURCE" {
  contents = "vault-agent"
}

env_template "SECRET_TIMESTAMP" {
  contents = "{{ with secret \"kv-demo/data/sample\" }}{{ .Data.metadata.created_time }}{{ end }}"
  error_on_missing_key = true
}

# C 프로그램 실행 (Agent가 환경변수와 함께 실행)
exec {
  command                   = ["./run_c_app.sh"]
  restart_on_secret_changes = "always"
  restart_stop_signal       = "SIGKILL"
}
```

**앱 실행 스크립트** (`run_c_app.sh`):
```bash
#!/bin/bash

# 기존 실행 종료
pkill -f "env-reader"

# 1초 대기
sleep 1

# C 프로그램 실행 (환경변수는 Agent가 자동으로 주입)
cd /path/to/c-app
./env-reader
```

**실행 방법**:
```bash
# Agent 실행 (환경변수 자동 주입하며 C 프로그램도 함께 실행)
vault agent -config=vault-agent.hcl
```

---

## 방법별 비교 및 선택 가이드

### 비교표

| 구분 | 1안 (API 직접 연계) | 2안 (Proxy) | 3안 (Agent) |
|------|-------------------|-------------|-------------|
| **개발 난이도** | 🔴 어려움 (토큰 관리) | 🟢 쉬움 | 🟡 보통 |
| **보안성** | 🟢 높음 (동적 토큰) | 🟢 높음 | 🟡 보통 (파일 노출) |
| **유연성** | 🟢 높음 (모든 기능) | 🟢 높음 | 🟡 제한적 |
| **운영 복잡도** | 🟡 보통 | 🔴 높음 (Proxy 관리) | 🟢 낮음 |
| **적합한 경우** | 신규 앱 | 간단한 앱 | 레거시 앱 |

### 선택 가이드

#### **신규 애플리케이션 개발**
→ **1안 (API 직접 연계)** 권장
- 가장 안전하고 유연함
- 토큰 갱신 로직 구현 필요
- **C언어**: [완성된 예제](./c-app/) 사용으로 토큰 갱신 로직 구현 불필요
- **Java**: [완성된 예제](./pure-java-app/) 사용으로 토큰 갱신 로직 구현 불필요

#### **간단한 애플리케이션**
→ **2안 (Vault Proxy)**
- 개발 속도가 빠름
- Proxy 서버 운영 필요

#### **레거시 애플리케이션**
→ **3안 (Vault Agent)**
- 기존 코드 수정 최소화
- 환경변수/파일 읽기만 추가

### 최종 권고사항

**개발 목표**: 코드에 시크릿을 절대 넣지 않기

**권장 순서**:
1. **신규 개발** → 1안 (API 직접 연계) - **C언어/Java는 완성된 예제 활용**
2. **간단한 앱** → 2안 (Vault Proxy)  
3. **레거시 앱** → 3안 (Vault Agent)

**공통 원칙**:
- 시크릿은 메모리에서만 사용
- 파일이나 로그에 저장하지 않기
- 토큰 만료 시간 고려하기
